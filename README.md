# Примеры для курса "Разработчик Java" в OTUS

Группа 2019-09

### Преподаватели
Сергей Петрелевич<br>
Вадим Тисов<br>
Константин Тарасов<br>
Стрекалов Павел<br>
Александр Оруджев<br>
Вячеслав Лапин<br>
Виталий Куценко<br>

Студент<br>
Султаняров Владислав Алексеевич<br>
eltgm@protonmail.com


Описание выполненных работ:<br>

### hw01-maven
Проект maven с модульной структурой
1) Создать аккаунт на github.com (если еще нет)
2) Создать репозиторий для домашних работ
3) Сделать checkout репозитория на свой компьютер
4) Создайте локальный бранч hw01-maven
5) Создать проект maven
6) В проект добавьте последнюю версию зависимости
<groupId>com.google.guava</groupId>
<artifactId>guava</artifactId>
7) Создайте модуль hw01-maven
8) В модуле сделайте класс HelloOtus
9) В этом классе сделайте вызов какого-нибудь метода из guava
10) Добавьте нужный плагин maven и соберите "толстый-jar"
11) Убедитесь, что "толстый-jar" запускается.
12) Сделайте pull-request в gitHub
13) Ссылку на PR отправьте на проверку.
### hw03-generics-collections
DIY ArrayList
Написать свою реализацию ArrayList на основе массива.
class DIYarrayList<T> implements List<T>{...}

Проверить, что на ней работают методы из java.util.Collections:
Collections.addAll(Collection<? super T> c, T... elements)
Collections.static <T> void copy(List<? super T> dest, List<? extends T> src)
Collections.static <T> void sort(List<T> list, Comparator<? super T> c)

1) Проверяйте на коллекциях с 20 и больше элементами.
2) DIYarrayList должен имплементировать ТОЛЬКО ОДИН интерфейс - List.
3) Если метод не имплементирован, то он должен выбрасывать исключение UnsupportedOperationException.
### hw06-gc
Сравнение разных сборщиков мусора
Написать приложение, которое следит за сборками мусора и пишет в лог количество сборок каждого типа
(young, old) и время которое ушло на сборки в минуту.

Добиться OutOfMemory в этом приложении через медленное подтекание по памяти
(например добавлять элементы в List и удалять только половину).

Настроить приложение (можно добавлять Thread.sleep(...)) так чтобы оно падало
с OOM примерно через 5 минут после начала работы.

Собрать статистику (количество сборок, время на сборки) по разным GC.

!!! Сделать выводы !!!
ЭТО САМАЯ ВАЖНАЯ ЧАСТЬ РАБОТЫ:
Какой gc лучше и почему?

Выводы оформить в файле Сonclusions.md в корне папки проекта.
Результаты измерений сведите в таблицу. 
### hw09-byteCodes
Автомагическое логирование.
Разработайте такой функционал:
метод класса можно пометить самодельной аннотацией @Log, например, так:

class TestLogging {
@Log
public void calculation(int param) {};
}

При вызове этого метода "автомагически" в консоль должны логироваться значения параметров.
Например так.

class Demo {
public void action() {
new TestLogging().calculation(6);
}
}

В консоле дожно быть:
executed method: calculation, param: 6

Обратите внимание: явного вызова логирования быть не должно. 
### hw10-annotations
Свой тестовый фреймворк
Написать свой тестовый фреймворк.

Поддержать свои аннотации @Test, @Before, @After.

Запускать вызовом статического метода с именем класса с тестами.

Т.е. надо сделать:
1) создать три аннотации - @Test, @Before, @After.
2) Создать класс-тест, в котором будут методы, отмеченные аннотациями.
3) Создать "запускалку теста". На вход она должна получать имя класса с тестами, в котором следует найти и запустить методы отмеченные аннотациями и пункта 1.
4) Алгоритм запуска должен быть следующий::
метод(ы) Before
текущий метод Test
метод(ы) After
для каждой такой "тройки" надо создать СВОЙ объект класса-теста.
5) Исключение в одном тесте не должно прерывать весь процесс тестирования.
6) На основании возникших во время тестирования исключений вывести статистику выполнения тестов (сколько прошло успешно, сколько упало, сколько было всего) 
### hw11-solid
Эмулятор банкомата
Написать эмулятор АТМ (банкомата).

Объект класса АТМ должен уметь:
- принимать банкноты разных номиналов (на каждый номинал должна быть своя ячейка)
- выдавать запрошенную сумму минимальным количеством банкнот или ошибку если сумму нельзя выдать
Это задание не на алгоритмы, а на проектирование.
Поэтому оптимизировать выдачу не надо.
- выдавать сумму остатка денежных средств
### hw13-structuralPatterns
Департамент ATM
Написать приложение ATM Департамент:
1) Департамент может содержать несколько ATM.
2) Департамент может собирать сумму остатков со всех ATM.
3) Департамент может инициировать событие – восстановить состояние всех
ATM до начального (начальные состояния у разных ATM могут быть
разными).
Это тренировочное задание на применение паттернов.
Попробуйте использовать как можно больше. 
### hw15-io
Cвой json object writer
Напишите свой json object writer (object to JSON string) аналогичный gson на основе javax.json.

Поддержите:
- массивы объектов и примитивных типов
- коллекции из стандартный библиотеки.
### hw17-jdbc
Самодельный ORM
Работа должна использовать базу данных H2.
Создайте в базе таблицу User с полями:

• id bigint(20) NOT NULL auto_increment
• name varchar(255)
• age int(3)

Создайте свою аннотацию @Id

Создайте класс User (с полями, которые соответствуют таблице, поле id отметьте аннотацией).

Напишите JdbcTemplate, который умеет работать с классами, в котрых есть поле с аннотацией @Id.
JdbcTemplate должен сохранять объект в базу и читать объект из базы.
Имя таблицы должно соответствовать имени класса, а поля класса - это колонки в таблице.

Методы JdbcTemplate'а:
void create(T objectData);
void update(T objectData);
void createOrUpdate(T objectData); // опционально.
<T> T load(long id, Class<T> clazz);

Фактически, надо создать "генератор запросов".
Сгенерированные запросы должны выполняться в уже готовом DbExecutor.


Проверьте его работу на классе User.

Метод createOrUpdate - необязательный.
Он должен "проверять" наличие объекта в таблице и создавать новый или обновлять.

Создайте еще одну таблицу Account:
• no bigint(20) NOT NULL auto_increment
• type varchar(255)
• rest number

Создайте для этой таблицы класс Account и проверьте работу JdbcTemplate на этом классе.
### hw19-hibernate
Использование Hibernate
Работа должна использовать базу данных H2.

Возьмите за основу предыдущее ДЗ (Самодельный ORM)
и реализуйте функционал сохранения и чтения объекта User через Hibernate.
(Рефлейсия больше не нужна)
Конфигурация Hibernate должна быть вынесена в файл.

Добавьте в User поля:
адрес (OneToOne)
class AddressDataSet {
private String street;
}
и телефон (OneToMany)
class PhoneDataSet {
private String number;
}

Разметьте классы таким образом, чтобы при сохранении/чтении объека User каскадно сохранялись/читались вложенные объекты.
Не забывайте про сохранение абстракций в приложении (см. комментарий в вебинаре). 
### hw21-cache
Свой cache engine
Закончите реализацию MyCache из вебинара.
Используйте WeakHashMap для хранения значений.

Добавьте кэширование в DBService из задания про Hibernate ORM или "Самодельный ORM".
Убедитесь, что ваш кэш действительно работает быстрее СУБД и сбрасывается при недостатке памяти.
### hw23-webServer
Веб сервер
Встроить веб сервер в приложение из ДЗ про Hibernate ORM.
Сделать админскую страницу, на которой админ должен авторизоваться.
На странице должны быть доступны следующие функции:
- создать пользователя
- получить список пользователей
### hw24-DI
Приложение с IoC контейнером
Собрать war для приложения из предыдущего ДЗ
Создавать основные классы приложения, как Spring beans (Кэш, Dao, DBService)
Настройку зависимостей выполнить с помощью Java/Annotation based конфигурации
Для обработки запросов использовать @Controller и/или @RestController
В качестве движка шаблонов использовать Thymeleaf
Запустить веб приложение во внешнем веб сервере 
### hw27-JMM
Последовательность чисел
Два потока печатают числа от 1 до 10, потом от 10 до 1.
Надо сделать так, чтобы числа чередовались, т.е. получился такой вывод:
Поток 1:1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1 2 3 4....
Поток 2: 1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1 2 3.... 
### hw28-messagingSystem
MessageSystem
Добавить систему обмена сообщениями в ДЗ про веб сервер с IoC контейнером.
Пересылать сообщения из вебсокета в DBService и обратно.
### hw31-multiprocess
MessageServer
Cервер из предыдущего ДЗ про MessageSystem разделить на три приложения:
• MessageServer
• Frontend
• DBServer
Запускать Frontend и DBServer из MessageServer.
Сделать MessageServer сокет-сервером, Frontend и DBServer клиентами.
Пересылать сообщения с Frontend на DBService через MessageServer.

Запустить приложение с двумя серверами фронтенд и двумя серверами баз данных на разных портах.
Если у вас запуск веб приложения в контейнере, то MessageServer может копировать root.war в контейнеры при старте 
### graduationWork
Облачный определитель номера с функцией блокировки 
1. callerIDServer
1.1. Метод для ввода данных об абоненте.
1.2. Метод для получения информации об абоненте. 
2. callerIDClient
2.1. Создание главного экрана приложения с возможностью просмотра номеров в списке спама, добавления или удаления других номеров.
2.2. Перехват входящего вызова от абонента.
2.3. Отправка запроса на сервер для получения информации об абоненте (передаём номер).
2.4. Создание формы для вывода информации об абоненте (описание или имя и категории спама, если есть).
2.5. Добавление пользователя в спам или закрытие формы
